{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Clock"},{"type":"text","text":" protocol in provides a powerful abstraction for time-based asynchrony in Swiftâ€™s"},{"type":"text","text":" "},{"type":"text","text":"structured concurrency. With just a single "},{"type":"codeVoice","code":"sleep"},{"type":"text","text":" method you can express many powerful async"},{"type":"text","text":" "},{"type":"text","text":"operators, such as timers, "},{"type":"codeVoice","code":"debounce"},{"type":"text","text":", "},{"type":"codeVoice","code":"throttle"},{"type":"text","text":", "},{"type":"codeVoice","code":"timeout"},{"type":"text","text":" and more (see"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"http:\/\/github.com\/apple\/swift-async-algorithms"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, the moment you use a concrete clock in your asynchronous code, or use "},{"type":"codeVoice","code":"Task.sleep"},{"type":"text","text":" "},{"type":"text","text":"directly, you instantly lose the ability to easily test and preview your features, forcing you to"},{"type":"text","text":" "},{"type":"text","text":"wait for real world time to pass to see how your feature works."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This library provides new "},{"type":"codeVoice","code":"Clock"},{"type":"text","text":" conformances ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/Clocks\/documentation\/Clocks\/TestClock"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Clocks\/documentation\/Clocks\/ImmediateClock"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Clocks\/documentation\/Clocks\/UnimplementedClock"},{"type":"text","text":") that allow you to turn any time-based asynchronous code into something that"},{"type":"text","text":" "},{"type":"text","text":"is easier to test and debug."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/clocks"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Clocks\/documentation\/Clocks","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A few clocks that make working with Swift concurrency more testable and more versatile."}],"kind":"symbol","metadata":{"roleHeading":"Framework","externalID":"Clocks","title":"Clocks","symbolKind":"module","role":"collection","modules":[{"name":"Clocks"}]},"hierarchy":{"paths":[[]]},"topicSections":[{"title":"Implementations","identifiers":["doc:\/\/Clocks\/documentation\/Clocks\/ImmediateClock","doc:\/\/Clocks\/documentation\/Clocks\/TestClock","doc:\/\/Clocks\/documentation\/Clocks\/UnimplementedClock"]},{"title":"Concrete erasure","identifiers":["doc:\/\/Clocks\/documentation\/Clocks\/AnyClock"]}],"references":{"doc://Clocks/documentation/Clocks/ImmediateClock":{"role":"symbol","title":"ImmediateClock","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ImmediateClock"}],"abstract":[{"type":"text","text":"A clock that does not suspend when sleeping."}],"identifier":"doc:\/\/Clocks\/documentation\/Clocks\/ImmediateClock","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ImmediateClock"}],"url":"\/documentation\/clocks\/immediateclock"},"doc://Clocks/documentation/Clocks/UnimplementedClock":{"role":"symbol","title":"UnimplementedClock","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnimplementedClock"}],"abstract":[{"type":"text","text":"A clock that causes an XCTest failure when any of its endpoints are invoked."}],"identifier":"doc:\/\/Clocks\/documentation\/Clocks\/UnimplementedClock","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"UnimplementedClock"}],"url":"\/documentation\/clocks\/unimplementedclock"},"doc://Clocks/documentation/Clocks/TestClock":{"role":"symbol","title":"TestClock","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"TestClock"}],"abstract":[{"type":"text","text":"A clock whose time can be controlled in a deterministic manner."}],"identifier":"doc:\/\/Clocks\/documentation\/Clocks\/TestClock","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TestClock"}],"url":"\/documentation\/clocks\/testclock"},"doc://Clocks/documentation/Clocks/AnyClock":{"role":"symbol","title":"AnyClock","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AnyClock"}],"abstract":[{"type":"text","text":"A type-erased clock."}],"identifier":"doc:\/\/Clocks\/documentation\/Clocks\/AnyClock","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AnyClock"}],"url":"\/documentation\/clocks\/anyclock"},"http://github.com/apple/swift-async-algorithms":{"title":"swift-async-algorithms","titleInlineContent":[{"type":"text","text":"swift-async-algorithms"}],"type":"link","identifier":"http:\/\/github.com\/apple\/swift-async-algorithms","url":"http:\/\/github.com\/apple\/swift-async-algorithms"},"doc://Clocks/documentation/Clocks":{"role":"collection","title":"Clocks","abstract":[{"type":"text","text":"A few clocks that make working with Swift concurrency more testable and more versatile."}],"identifier":"doc:\/\/Clocks\/documentation\/Clocks","kind":"symbol","type":"topic","url":"\/documentation\/clocks"}}}